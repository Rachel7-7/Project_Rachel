#!/usr/bin/env python

"""
Plays a raw drum sound repeatedly at the BPM and rhythm type specified by the user.
Press SPACE to check timing accuracy. Press B to stop.
"""

import os.path
import sys
import pygame
import time

main_dir = os.path.split(os.path.abspath(__file__))[0]

def main(file_path=None):
    if file_path is None:
        file_path = os.path.join(main_dir, 'data', 'drum.wav')  # é»˜è®¤é¼“å£°æ–‡ä»¶è·¯å¾„

    # ç”¨æˆ·è¾“å…¥ BPM
    while True:
        try:
            bpm_input = input("Enter BPM (beats per minute, integer): ")
            bpm = int(bpm_input)
            if bpm <= 0:
                raise ValueError
            break
        except ValueError:
            print("âš ï¸  Please enter a positive integer (e.g., 120).")

    # ç”¨æˆ·é€‰æ‹©èŠ‚å¥ç±»åž‹
    rhythm_options = {
        "triplets": [3, "Triplets (3 per beat)"],
        "quarter": [1, "Quarter notes (1 per beat)"],
        "eighth": [2, "Eighth notes (2 per beat)"],
        "16+8": [[4, 2], "Four 16th notes + Four 8th notes"]
    }

    print("\nðŸŽµ Rhythm options:")
    for key, val in rhythm_options.items():
        print(f" - {key} : {val[1]}")

    while True:
        rhythm_choice = input("\nEnter rhythm type: ").strip().lower()
        if rhythm_choice in rhythm_options:
            break
        print("âš ï¸  Invalid rhythm type. Try again.")

    # åˆå§‹åŒ– pygame
    pygame.init()
    pygame.mixer.init()
    pygame.display.set_mode((200, 100))  # é¿å…æ— çª—å£å“åº”

    # åŠ è½½é¼“å£°
    sound = pygame.mixer.Sound(file_path)

    # ä¸€ä¸ªæ‹å­çš„æ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰
    beat_duration_ms = 60000 // bpm

    print(f"\nðŸŽµ Current BPM: {bpm}")
    print(f"ðŸŽ¼ Rhythm: {rhythm_options[rhythm_choice][1]}")
    print("â–¶ï¸  Starting playback. Press SPACE to tap in rhythm. Press B to stop.\n")

    running = True
    clock = pygame.time.Clock()
    last_play_time = None
    play_times = []
    tap_errors = []

    def handle_events():
        nonlocal running, tap_errors, last_play_time
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and last_play_time is not None:
                    tap_time = time.time()
                    error_ms = int((tap_time - last_play_time) * 1000)
                    diff = error_ms
                    tap_errors.append(diff)
                    if diff < -120:
                        print(f"â— Too early by {-diff} ms")
                    elif diff > 120:
                        print(f"â— Too late by {diff} ms")
                    else:
                        print(f"âœ… On time (Â±{diff} ms)")
                elif event.key == pygame.K_b:
                    running = False

    def play_and_track():
        nonlocal last_play_time
        sound.play()
        last_play_time = time.time()

    if rhythm_choice == "16+8":
        # æ’­æ”¾ä¸€ä¸ªå¾ªçŽ¯èŠ‚å¥ï¼š4 ä¸ªåå…­åˆ†éŸ³ç¬¦ + 4 ä¸ªå…«åˆ†éŸ³ç¬¦
        while running:
            durations = [beat_duration_ms // 4] * 4 + [beat_duration_ms // 2] * 4
            for duration in durations:
                play_and_track()
                for _ in range(duration // 10):
                    handle_events()
                    pygame.time.wait(10)
                if not running:
                    break
    else:
        notes_per_beat = rhythm_options[rhythm_choice][0]
        interval = beat_duration_ms // notes_per_beat

        while running:
            play_and_track()
            for _ in range(interval // 10):
                handle_events()
                pygame.time.wait(10)

    print("â¹ Playback stopped.")
    if tap_errors:
        avg_error = sum(tap_errors) / len(tap_errors)
        print(f"\nðŸ“Š You tapped {len(tap_errors)} times.")
        print(f"ðŸ“ˆ Average timing error: {avg_error:.1f} ms")
    else:
        print("ðŸ“­ No taps detected.")

    pygame.quit()

if __name__ == '__main__':
    if len(sys.argv) > 1:
        main(sys.argv[1])
    else:
        main()
